struct RccRegister {
    CFGR: u32,
    AB2XR: u32,
}

struct Array<T> {
    allocator: Allocator,
    length: u32,
    capacity: u32,
    data: [T],
}

impl Array<T> {
    fn new(allocator: Allocator) -> Self {
        ret Self {
            allocator,
            length: 0,
            capacity: 0,
            data: [],
        }
    }

    fn delete(self: &Self) {
        self.allocator.free(self.data);
    }

    fn push(self: &mut Self, element: T) {
        if self.length == self.capacity {
            self.capacity = self.capacity / 2 + 8;
            self.data = self.allocator.realloc(self.data);
        }

        self.data[self.length] = element;
        self.length += 1;
    }

    fn pop(self: &mut Self) -> T {
        self.length -= 1;
        let element = self.data[self.length]; 

        ret element;
    }

    fn len(self: &Self) {
        ret self.length;
    }
}

trait Debug {
    fn Print(self: &Self);
}

impl Debug for Array<T> {
    fn print(self: &Self) {
        for element in data {
            print_line "Array length={self.length}";
            print_line "      capacity={self.capacity}";
        }
    }
}

fn test() {
    Array<u32> arr = Array.new();
    arr.push Math.abs -1;
    arr.push 2;
    arr.push 99;

    for i in 0..10 {
        arr.push i;
    }

    print_line arr; // 1, 2, 99, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
}

let arr = Array.new<T>();

export const RCC = add_2(0x40000000) as &RccRegister;

macro volatile {
    ($macro $x:sym = $y:expr) => {
        std.volatile_write($x, $y);
    },

    ($macro $x:sym) => {
        std.volatile_read($x);
    },

    ($macro $x:sym ($op:any)= $y:expr) => {
        std.volatile_write($x, std.volatile_read($x) $op $y);
    }
}

export fn add_2(x: i32) -> i32 {
    @volatile RCC.CFGR |= 0x01 + 2;

    let a: [u8:8] = "Hello";
    let b: &[u8] = a[0..3];

    let c = a.push_str(b); // HelloHel\0

    ret x + 2;
}
